# Custom Semgrep Rules
#
# Currently covers:
# - Preventing SQL injection by using prepared statements
# - Enforce React components are wrapped with memo when appropriate

rules:
  # Rule: Enforce React components are wrapped with memo()
  # All React components should be memoized to prevent unnecessary re-renders,
  # unless they subscribe to Redux state using useAppSelector or useSelector.
  - id: react-component-missing-memo
    patterns:
      # Match function declarations that return JSX anywhere in the function
      - pattern-either:
          - patterns:
              - pattern: |
                  function $COMPONENT($PROPS) { ... }
              # Component name must start with uppercase (React convention)
              - metavariable-regex:
                  metavariable: $COMPONENT
                  regex: "^[A-Z].*"
              # Must contain JSX elements
              - pattern-inside: |
                  function $COMPONENT(...) {
                    ...
                    <$JSX>...</$JSX>
                    ...
                  }
          - patterns:
              - pattern: |
                  const $COMPONENT = ($PROPS) => { ... }
              - metavariable-regex:
                  metavariable: $COMPONENT
                  regex: "^[A-Z].*"
              - pattern-inside: |
                  const $COMPONENT = (...) => {
                    ...
                    <$JSX>...</$JSX>
                    ...
                  }
          - patterns:
              - pattern: |
                  const $COMPONENT = function($PROPS) { ... }
              - metavariable-regex:
                  metavariable: $COMPONENT
                  regex: "^[A-Z].*"
              - pattern-inside: |
                  const $COMPONENT = function(...) {
                    ...
                    <$JSX>...</$JSX>
                    ...
                  }
      # Exclude components already wrapped with memo
      - pattern-not: |
          const $COMPONENT = memo(...)
      # Exclude components that use Redux hooks (need to re-render on state changes)
      - pattern-not-inside: |
          const $X = ($ARGS) => {
            ...
            useAppSelector(...)
            ...
          }
      - pattern-not-inside: |
          const $X = ($ARGS) => {
            ...
            useSelector(...)
            ...
          }
      - pattern-not-inside: |
          function $F(...) {
            ...
            useAppSelector(...)
            ...
          }
      - pattern-not-inside: |
          function $F(...) {
            ...
            useSelector(...)
            ...
          }
    message: >-
      React component '$COMPONENT' should be wrapped with memo() for performance optimization.

      Components should be memoized to prevent unnecessary re-renders when parent components update.

      Note: memo() should not be used with components that subscribe to Redux state using
      useAppSelector or useSelector. Components that only use useAppDispatch can still be memoized.
    languages:
      - typescript
    paths:
      exclude:
        - "**/*.test.tsx"
        - "**/*.test.ts"
        - "**/test-*.tsx"
        - "**/test-*.ts"
    severity: WARNING
    metadata:
      category: performance
      confidence: HIGH
      likelihood: MEDIUM
      impact: MEDIUM
      subcategory:
        - audit
  # Rule: Ban db.exec() in favor of prepared statements
  # The exec() method doesn't support parameter binding, making it inherently unsafe
  # for any dynamic values. This project exclusively uses prepared statements.
  # This rule bans ALL usage of exec(), not just unsafe patterns.
  - id: better-sqlite3-ban-exec
    pattern: $DB.exec(...)
    message: >-
      The exec() method is banned in this codebase. It doesn't support parameter binding,
      making it unsafe for any queries with dynamic values. Use prepare() instead.
    languages:
      - typescript
      - javascript
    severity: ERROR
    metadata:
      category: security
      confidence: HIGH
      likelihood: HIGH
      impact: HIGH
      subcategory:
        - vuln

  # Rule: Ban ALL dynamic content in prepare() statements
  # Only allow template literals with safe constants (FetchStatus, EventStatus,
  # MESSAGE_PREVIEW_LENGTH).
  # Exception: selectWhereIn method uses TypeScript string literal types for safety.
  - id: better-sqlite3-ban-dynamic-content
    patterns:
      - pattern: $DB.prepare(`...${$VAR}...`)
      # Exclude safe constants
      - pattern-not: $DB.prepare(`...${FetchStatus.$FIELD}...`)
      - pattern-not: $DB.prepare(`...${EventStatus.$FIELD}...`)
      - pattern-not: $DB.prepare(`...${MESSAGE_PREVIEW_LENGTH}...`)
      # Exclude selectWhereIn which is validated by using string literal types
      - pattern-not-inside: |
          selectWhereIn(...) {
            ...
          }
    message: >-
      Dynamic content in SQL prepare() statements is banned for security.
      Template literals with variables can lead to SQL injection.

      Required: Use parameterized queries with ? or @name placeholders:
        - CORRECT: db.prepare('SELECT * FROM users WHERE id = ?').get(userId)
        - CORRECT: db.prepare('SELECT * FROM users WHERE name = @name').get({ name })
        - WRONG: db.prepare(`SELECT * FROM users WHERE id = ${userId}`)

      Exception: FetchStatus and EventStatus enum values are allowed as they are compile-time constants.

      Note: selectWhereIn uses TypeScript string literal types for compile-time safety.
    languages:
      - typescript
      - javascript
    severity: ERROR
    metadata:
      category: security
      confidence: HIGH
      likelihood: HIGH
      impact: HIGH
      subcategory:
        - vuln

  # Rule: Enforce database operation centralization
  # All database operations must go through the DB class in src/main/database/index.ts
  # This ensures consistent security practices and makes auditing easier.
  - id: better-sqlite3-centralize-db-operations
    pattern: $DB.prepare(...)
    paths:
      exclude:
        - "**/*/src/main/database/index.ts"
    message: >-
      Database operations must be centralized in src/main/database/index.ts for security and maintainability.
      All SQL queries should go through the DB class methods.

      Do not use db.prepare() directly outside the database module.
      Instead, add a method to the DB class that encapsulates your query.

      This ensures:
        - Consistent security practices
        - Easier auditing of all SQL queries
        - Single source of truth for database operations
    languages:
      - typescript
      - javascript
    severity: ERROR
    metadata:
      category: security
      confidence: HIGH
      likelihood: HIGH
      impact: HIGH
      subcategory:
        - vuln
